#!/usr/bin/env python

"""Filter stdin line-by-line based on keyword filters.

- TODO: "smart case" filter --- if query includes caps -> case sensitive,
  insensitive, otherwise.

- TODO: Can't distinguish.

  $ fv jhu nlp Grammar.java
  ./src/main/java/edu/jhu/nlp/parsing/grammar/Grammar.java
  ./src/main/java/edu/jhu/nlp/parsing/grammar/ConvertSlavGrammar.java

  - [2018-05-15 Tue] Related annoyance

    $ p scea
    /home/timv/projects/presentations/papers/2018-scea
    /home/timv/projects/scea

    The issue: I can refine the query to hit the first one "scea papers", but
    that latter requires "projects/scea" (with the slash), which is a annoying
    to think of and to type. The recency heuristic just means the result is a
    unpredictable as I'm currently swapping between these two projects
    constantly.

- TODO: underscore/lackof is a problem.

  Neither 'two_line_search' or 'twolinesearch' match the query 'two line search'

- TODO [2020-10-23 Fri] Idea use the augmented history file to determine whether
  past searches were successful.  As a noisy signal, we can find previous
  invocations of `fv` which were followed by a large enough pause (these
  commands are timestamped).

"""
import re, os, sys
from sys import stdin
from itertools import cycle
from path import Path
from argparse import ArgumentParser
from subprocess import Popen, PIPE


colors = red, green, yellow, blue, magenta, cyan = \
    ['\033[3%sm%%s\033[0m' % i for i in range(1,7)]


def unique(iterable):
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique('AAAABBBCCDAABBB') --> A B C D
    # unique('ABBCcAD') --> A B C D
    seen = set()
    seen_add = seen.add
    for x in iterable:
        if x not in seen:
            seen_add(x)
            yield x


# TODO: create a submodule with common filters so that we can use this in
# notes.py
def filter2(f):
    "Content-based file filters."
    # TODO: add to where ever org-mode export files are filtered
    if os.path.exists(f):
        if f.endswith('.c') or f.endswith('.cpp'):
            if '/* Generated by Cython' in open(f, encoding='utf-8', errors='ignore').read(1024):
                return False
            if '#error Do not use this file' in open(f, encoding='utf-8', errors='ignore').read(1024):
                return False
        if f.endswith('.html'):
            if '<!-- Generated by Cython' in open(f, encoding='utf-8', errors='ignore').read(1024):
                return False
        if f.endswith('.tex'):
            if 'Emacs Org-mode version' in open(f, encoding='utf-8', errors='ignore').read(1024):
                return False
        if f.endswith('.pdf'):
            if 'Emacs Org-mode version' in open(f, encoding='utf-8', errors='ignore').read(128*1024):
                return False
        # ignore latex's junk
        if re.findall('\.(blg|aux|log|bbl|out)$', f): # looks like a tex output
            # check for similarly named tex file
            if os.path.exists(re.sub('\.(blg|aux|log|bbl|out)$', '.tex', f)):
                return False

    return True


def run(filters, lines, color=True):

    # cleanup.
    lines = [l.strip() for l in lines]

    # substring match -> higher recall
    filters = [re.compile(re.escape(f), re.I) for f in filters]

    for line in unique(lines):

        if not all(f.findall(line) for f in filters):
            continue

        if not filter2(line):
            continue

        if color:
            for f, c in zip(filters, cycle(colors)):
                line = f.sub(lambda m, c=c: c % m.group(0), line)

        yield line


def main():

    # "if (pattern1 and pattern2 ...) then action"

    parser = ArgumentParser(description='Filter a sequence of lines by matching patterns.')
    parser.add_argument('filters', nargs='*', help='filters, each is a regex')

    parser.add_argument('--top', action='store_true', help='call on-unique on the top hit (if there is one).')

    parser.add_argument('--on-unique', help='When a single match is found execute this command.')
    parser.add_argument('--on-fail', help='When a no match is found execute this command.')

    parser.add_argument('-C', '--no-color', dest='color', action='store_false',
                        help='Do not print ANSI color codes.')

    parser.add_argument('-N', dest='msg', action='store_false',
                        help='omit "no results" msg')

    args = parser.parse_args()

    matches = run(filters = args.filters,
                  lines = stdin,
                  color = args.color)

    matches = list(matches)

    high = []
    filters = [re.compile(re.escape(f), re.I) for f in args.filters]
    for m in matches:
        b = Path(m).basename()
        if any(f.findall(b) for f in filters):
            high.append(m)

    if len(high) == 1:
        print(yellow % '-> using high-priority match', file=sys.stderr)
        matches = high

    if not matches:
        if args.msg:
            print(red % 'no results', file=sys.stderr)
        exit(1)

    if args.top:
        print(matches[0])
    else:
        for m in matches:
            print(m)

    if len(matches) == 1 or args.top:
        if args.on_unique:
            cmd = args.on_unique.format(match=re.sub(r'\033\[.*?m', '', matches[0]))
            Popen(cmd,
                  stdout=PIPE,
                  stdin=PIPE,
                  stderr=PIPE,
                  shell=True,
                  close_fds=True)

        exit(0)

    elif len(matches) == 0:
        if args.on_fail:
            os.system(args.on_fail)
        exit(1)

    else:
        exit(2)

#    if len(matches) == 1:
#        match = matches[0].strip()
#        if not os.path.isdir(match):
#            os.system('gnome-open %s' % matches[0])


if __name__ == '__main__':
    main()
